{"version":3,"names":[],"sources":["WasmSample.cpp","../SimpleSound_wasm.cpp"],"sourcesContent":["// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n\t// The linker synthesizes this to call constructors.\n\t__wasm_call_ctors();\n}\n\nextern \"C\" void* WasmAllocate(unsigned int bytes, unsigned int alignment);\nextern \"C\" void  WasmRelease(void* ptr);\nextern \"C\" void* WasmCopy(void* dst, const void* src, unsigned int bytes);\nextern \"C\" void* WasmClear(void* dst, unsigned int bytes); \n\nextern \"C\" unsigned int WasmGetCurrentPosition();\nextern \"C\" unsigned int WasmGetNumSamples();\n\nextern unsigned char __heap_base;\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void* WasmHeapBase(void) {\n  return &__heap_base;\n}\n\nextern \"C\" float MathCos(float x);\nextern \"C\" float MathSin(float x);\nextern \"C\" float MathSqrt(float x);\n\ntypedef void (*OnFileLoaded)(const char* path, void* data, unsigned int bytes, void* userData);\nextern \"C\" void FileLoad(const char* path, void* target, unsigned int bytes, OnFileLoaded callback, void* userData);\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void TriggerWasmLoaderCallback(OnFileLoaded callback, const char* path, void* data, unsigned int bytes, void* userdata) {\n\tcallback(path, data, bytes, userdata);\n}\n\n#include \"../SimpleSound.h\"\n#include \"../SimpleSound_wasm.cpp\"\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\"\n\nusing namespace SimpleSound;\n\nstruct LoadedFile {\n\tvoid* data;\n\tunsigned int bytes;\n};\n\nstruct UserData {\n\tDevice* device;\n\tLoadedFile* pcm1;\n\tLoadedFile* pcm2;\n\tLoadedFile* pcm3;\n\tunsigned int pcmsLoaded;\n};\n\nvoid FileLoadedCallback(const char* path, void* data, unsigned int bytes, void* userData) {\n\tif (data != 0) {\n\t\t*(unsigned int*)userData = *(unsigned int*)userData + 1; \n\t}\n\telse {\n\t\tint stop = 7;\n\t}\n}\n\nexport void* StartSample() {\n  UserData* result = (UserData*)WasmAllocate(sizeof(UserData), 0);\n  result->pcmsLoaded = 0;\n\n\tSimpleSound::Platform plat;\n\tplat.allocate = [](unsigned int bytes) {\n\t\treturn WasmAllocate(bytes, 0);\n\t};\n\tplat.release = [](void* mem) {\n\t\tWasmRelease(mem);\n\t};\n\tplat.cos = [](float v) {\n\t\treturn MathCos(v);\n\t};\n\tplat.sin = [](float v) {\n\t\treturn MathSin(v);\n\t};\n\tplat.sqrt = [](float v) {\n\t\treturn MathSqrt(v);\n\t};\n\n\tresult->pcm1 = (LoadedFile*)WasmAllocate(sizeof(LoadedFile), 0);\n\tresult->pcm2 = (LoadedFile*)WasmAllocate(sizeof(LoadedFile), 0);\n\tresult->pcm3 = (LoadedFile*)WasmAllocate(sizeof(LoadedFile), 0);\n\n\tresult->pcm1->bytes = 1024 * 1024 * 8;\n\tresult->pcm2->bytes = 1024 * 1024 * 8;\n\tresult->pcm3->bytes = 1024 * 1024 * 8;\n\n\tresult->pcm1->data = WasmAllocate(result->pcm1->bytes, 0);\n\tresult->pcm2->data = WasmAllocate(result->pcm2->bytes, 0);\n\tresult->pcm3->data = WasmAllocate(result->pcm3->bytes, 0);\n\n\tconst char* pcm_path1 = \"pcm/piano.wav\";\n\tconst char* pcm_path2 = \"pcm/equinox.wav\";\n\tconst char* pcm_path3 = \"pcm/LRMonoPhase4.wav\";\n\n\tFileLoad(pcm_path1, result->pcm1->data, result->pcm1->bytes, FileLoadedCallback, &result->pcmsLoaded);\n\tFileLoad(pcm_path2, result->pcm1->data, result->pcm1->bytes, FileLoadedCallback, &result->pcmsLoaded);\n\tFileLoad(pcm_path3, result->pcm1->data, result->pcm1->bytes, FileLoadedCallback, &result->pcmsLoaded);\n\n\tresult->device = InitWithSamples(plat, WasmGetNumSamples(), 2, 0);\n\treturn result;\n}\n\nexport void UpdateSample(void* userData, float dt) {\n\tUserData* u = (UserData*)userData;\n\tif (u ->pcmsLoaded != 3) {\n\t\treturn;\n\t}\n\tint stop = 8;\n\tint now = 9;\n}\n","#include \"SimpleSound.h\"\n\n#undef PlaySound\n\n#define SIMPLE_SOUND_MAX_CHANNELS 6\n#define SIMPLE_SOUND_NUM_COMMANDS 512\n#define SIMPLE_SOUND_ERROR_MSG_LEN 512\n#define SIMPLE_SOUND_PI_4 0.78539816339f\n#define SIMPLE_SOUND_SQRT2_2 0.70710678118f\n\nextern \"C\" void WasmSubmitPcmBytes(void* device, unsigned int _writePointer, void* data, unsigned int dataSize); // js function\nextern \"C\" unsigned int WasmGetCurrentPosition();\nextern \"C\" void WasmRegisterAudioDevice(void* device);\nextern \"C\" void WasmRemoveAudioDevice(void* device);\n\nnamespace SimpleSound {\n\tstruct Device {\n\t\tPlatform platform;\n\t\tunsigned int numChannels;\n\n\t\tbool isValid;\n\t\tchar* errorMsg;\n\t\tfloat getResult[4]; // For GetPosition, GetVolume, etc...\n\n\t\tBus* buses;\n\n\t\tfloat volume;\n\t\tfloat pan;\n\n\t\tfloat gainLeft; // For 2d panning\n\t\tfloat gainRight; // For 2d panning\n\n\t\tfloat listenerPosition[3];\n\t\tfloat listenerForward[3];\n\t\tfloat listenerUp[3];\n\t\tfloat listenerMat[9];\n\t\t\n\t\tunsigned int activeChunkIndex;\n\t\tfloat* mixer; // = new float[numSamples * numChannels]\n\t\tshort* buffer; // new short[numSamples * numChannels * 2]\n\t\tshort* buffer_unaligned; // new short[numSamples * numChannels * 2]\n\t\tunsigned int bufferSize; // sizeof(chunk) * 2 (measured in bytes)\n\t\tunsigned int numSamples; // Per chunk\n\t\tbool mRightHanded; // OpenGL style, forward -1\n\t};\n\n\tstruct PCMData { \n\t\tDevice* owner;\n\t\tshort* samples; // samples = new short[numSamples * numChannels];\n\t\tunsigned int numSamples;\n\t\tunsigned int numChannels; // Always the same as the Device that created it\n\t};\n\n\tstruct Bus {\n\t\tDevice* owner;\n\t\tSound* sounds;\n\n\t\tBus* prev;\n\t\tBus* next;\n\n\t\tfloat volume;\n\t\tfloat pan;\n\n\t\tfloat gainLeft; // For panning\n\t\tfloat gainRight; // For panning\n\n\t\t// Interleaved buffer, ie: mix = new float[numSamples * numChannels];\n\t\tfloat* mix; // [channel1,channel2..channeln, channel1,channel2..channeln, etc..]\n\t\tbool clear;\n\t};\n\n\tstruct Sound {\n\t\tPCMData* source;\n\t\tBus* owner;\n\n\t\tSound* prev;\n\t\tSound* next;\n\n\t\tbool looping;\n\t\tbool paused;\n\t\t\n\t\tunsigned int cursor;\n\n\t\tfloat volume;\n\n\t\tfloat pan;\n\t\tfloat gainLeft;\n\t\tfloat gainRight;\n\n\t\tbool isSpatialized;\n\t\tfloat position[3];\n\t\tfloat minAttenuation;\n\t\tfloat maxAttenuation;\n\t};\n\n\tstruct LeftRightGain {\n\t\tfloat leftGain;\n\t\tfloat rightGain;\n\t};\n\n\tinline void Cross(float* out, float* a, float* b) {\n\t\tout[0] = a[1] * b[2] - a[2] * b[1];\n\t\tout[1] = a[2] * b[0] - a[0] * b[2];\n\t\tout[2] = a[0] * b[1] - a[1] * b[0];\n\t}\n\n\tinline float Dot(float* a, float* b) {\n\t\treturn a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n\t}\n\n\tinline void Normalize(Platform& plat, float* v) {\n\t\tfloat lenSq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n\t\tif (lenSq > 0.00001f) {\n\t\t\tfloat inv_len = 1.0f / plat.sqrt(lenSq);\n\t\t\tv[0] *= inv_len;\n\t\t\tv[1] *= inv_len;\n\t\t\tv[2] *= inv_len;\n\t\t}\n\t}\n\n\tinline void Mul(float* result, float* mat, float* vec) {\n\t\tfloat v[3] = { vec[0], vec[1], vec[2] };\n\t\tresult[0] = v[0] * mat[0 * 3 + 0] + v[1] * mat[1 * 3 + 0] + v[2] * mat[2 * 3 + 0];\n\t\tresult[1] = v[0] * mat[0 * 3 + 1] + v[1] * mat[1 * 3 + 1] + v[2] * mat[2 * 3 + 1];\n\t\tresult[2] = v[0] * mat[0 * 3 + 2] + v[1] * mat[1 * 3 + 2] + v[2] * mat[2 * 3 + 2];\n\t}\n\n\tinline unsigned int uiMax(unsigned int _a, unsigned int _b) {\n\t\tif (_a >= _b) {\n\t\t\treturn _a;\n\t\t}\n\t\treturn _b;\n\t}\n\n\tinline unsigned int uiMin(unsigned int _a, unsigned int _b) {\n\t\tif (_a <= _b) {\n\t\t\treturn _a;\n\t\t}\n\t\treturn _b;\n\t}\n\n\tinline unsigned int StrLen(const char* str) {\n\t\tconst char* iter;\n\t\tfor (iter = str; *iter; ++iter);\n\t\treturn (iter - str);\n\t}\n\n\tinline char* StrCpy(char* dest, const char* src) {\n\t\tunsigned int bytes = StrLen(src) + 1;\n\n\t\tchar* d = (char*)dest;\n\t\tchar* s = (char*)src;\n\t\tfor (unsigned int i = 0; i < bytes; ++i) {\n\t\t\td[i] = s[i];\n\t\t}\n\t\treturn dest;\n\t}\n\n\tLeftRightGain LeftAndRightGainFromPan(Device& device, float pan) {\n\t\tif (pan < -1.0f) {\n\t\t\tpan = -1.0f;\n\t\t}\n\t\tif (pan > 1.0f) {\n\t\t\tpan = 1.0f;\n\t\t}\n\n\t\tfloat angle = double(pan) * SIMPLE_SOUND_PI_4;\n\t\tfloat cos_angle = device.platform.cos(angle);\n\t\tfloat sin_angle = device.platform.sin(angle);\n\n\t\tLeftRightGain result;\n\t\tresult.leftGain = (SIMPLE_SOUND_SQRT2_2 * (cos_angle - sin_angle));\n\t\tresult.rightGain = (SIMPLE_SOUND_SQRT2_2 * (cos_angle + sin_angle));\n\t\treturn result;\n\t}\n\n\tLeftRightGain LinearGainFromPan(Device& device, float pan) {\n\t\tif (pan < -1.0f) {\n\t\t\tpan = -1.0f;\n\t\t}\n\t\tif (pan > 1.0f) {\n\t\t\tpan = 1.0f;\n\t\t}\n\n\t\tfloat leftPan = (pan + 1.0f) / 2.0f;\n\t\tfloat rightPan = 1.0f - leftPan;\n\n\t\tLeftRightGain result;\n\t\tresult.leftGain = leftPan;\n\t\tresult.rightGain = rightPan;\n\t\treturn result;\n\t}\n\t\n\tshort* GetBuffer(Device& device) {\n\t\treturn device.buffer;\n\t}\n\n\tunsigned int GetBufferSize(Device& device) {\n\t\treturn device.bufferSize;\n\t}\n\n\tshort* GetBuffer(PCMData& pcm) {\n\t\treturn pcm.samples;\n\t}\n\n\tunsigned int GetNumSamples(PCMData& pcm) {\n\t\treturn pcm.numSamples;\n\t}\n\n\tPCMData* LoadWavFromMemory(Device& device, void* data, unsigned int bytes) {\n\t\tPCMData* result = (PCMData*)device.platform.allocate(sizeof(PCMData));\n\n\t\tresult->owner = &device;\n\t\tresult->numChannels = device.numChannels;\n\n\t\tchar* cursor = ((char*)data); \n\t\tcursor += 22;\n\n\t\tunsigned short numChannels = *(unsigned short*)cursor;\n\t\tcursor += 2;\n\n\t\tunsigned int samplingRate = *(unsigned int*)cursor;\n\t\tcursor += 4;\n\t\t\n\t\tcursor = ((char*)data);\n\t\tcursor += 34;\n\n\t\tunsigned short bitsPerSample = *(unsigned short*)cursor;\n\n\t\tcursor = ((char*)data);\n\t\tcursor += 40;\n\n\t\tunsigned int dataLength = *(unsigned int*)cursor;\n\t\tcursor += 4;\n\n\t\tresult->numSamples = dataLength / (sizeof(short) * numChannels);\n\t\tresult->samples = (short*)device.platform.allocate(dataLength);\n\n\t\tshort* source = (short*)cursor;\n\t\tunsigned int numSamples = result->numSamples;\n\t\tfor (unsigned int sample = 0; sample < numSamples * numChannels; ++sample) {\n\t\t\tresult->samples[sample] = source[sample];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvoid Destroy(PCMData* pcm) {\n\t\tpcm->owner->platform.release(pcm->samples);\n\t\tpcm->owner->platform.release(pcm);\n\t}\n\n\t// Returns true if the sound finished mixing and needs to be removed\n\tbool Mix(Bus& destination, Sound& source, unsigned int destOffsetInSamples, bool clear) {\n\t\tfloat volume = source.volume;\n\t\tshort* samples = source.source->samples;\n\t\tunsigned int pcmNumSamples = source.source->numSamples;\n\t\tunsigned int numChannels = destination.owner->numChannels;\n\t\tbool looping = source.looping;\n\n\t\tif (source.paused) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfloat gain[SIMPLE_SOUND_MAX_CHANNELS];\n\t\tfor (int i = 0; i < SIMPLE_SOUND_MAX_CHANNELS; gain[i++] = 0.0f);\n\t\tgain[0] = 1.0f;\n\t\tif (numChannels >= 2) {\n\t\t\tgain[0] = source.gainLeft;\n\t\t\tgain[1] = source.gainRight;\n\t\t}\n\n\t\tif (source.isSpatialized) {\n\t\t\tconst float speakers[6][6 * 3] = { // Positions copied from soloud\n\t\t\t\t{0, 0, 1,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0},\n\t\t\t\t{2, 0, 1,   -2, 0, 1,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0},\n\t\t\t\t{0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0},\n\t\t\t\t{2, 0, 1,   -2, 0, 1,   2, 0, -1,   -2, 0, 1,   0, 0, 0,   0, 0, 0},\n\t\t\t\t{0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0,   0, 0, 0},\n\t\t\t\t{2, 0, 1,   -2, 0, 1,   0, 0, 1,   0, 0, 1,   2, 0, -1,   -2, 0, -1},\n\t\t\t};\n\n\t\t\tDevice* device = destination.owner;\n\t\t\tfloat listenerPos[3] = { device->listenerPosition[0], device->listenerPosition[1], device->listenerPosition[2] };\n\t\t\tfloat soundRelativeToListener[3] = {\n\t\t\t\tsource.position[0] - listenerPos[0],\n\t\t\t\tsource.position[1] - listenerPos[1],\n\t\t\t\tsource.position[2] - listenerPos[2]\n\t\t\t};\n\t\t\tfloat distanceSq = Dot(soundRelativeToListener, soundRelativeToListener);\n\t\t\tNormalize(device->platform, soundRelativeToListener);\n\t\t\tMul(soundRelativeToListener, device->listenerMat, soundRelativeToListener);\n\n\t\t\tfor (unsigned int i = 0; i < device->numChannels; ++i) {\n\t\t\t\tfloat speakerRelativeToListener[3] = {\n\t\t\t\t\tspeakers[device->numChannels - 1][i * 3 + 0],\n\t\t\t\t\tspeakers[device->numChannels - 1][i * 3 + 1],\n\t\t\t\t\tspeakers[device->numChannels - 1][i * 3 + 2]\n\t\t\t\t};\n\t\t\t\tNormalize(device->platform, speakerRelativeToListener);\n\n\t\t\t\tgain[i] = Dot(soundRelativeToListener, speakerRelativeToListener);\n\t\t\t\tgain[i] = (gain[i] + 1.0f) / 2.0f; // Normalize 0 to 1\n\t\t\t}\n\t\t\tif (device->numChannels == 6) {\n\t\t\t\tgain[3] = 1.0f; // Sub should mix everything?\n\t\t\t}\n\n\t\t\tif (distanceSq > 0.00001f) {\n\t\t\t\tfloat distance = device->platform.sqrt(distanceSq);\n\t\t\t\tif (distance < source.minAttenuation) {\n\t\t\t\t\t// Don't attenuate sounds if closer than the min attenuation distance\n\t\t\t\t\t//for (int i = 0; i < device->numChannels; gain[i++] = 1.0f);\n\t\t\t\t}\n\t\t\t\telse if (distance > source.maxAttenuation) { // Too far, mute sound\n\t\t\t\t\tfor (int i = 0; i < device->numChannels; gain[i++] = 0.0f);\n\t\t\t\t}\n\t\t\t\telse { // Lerp\n\t\t\t\t\tfloat range = source.maxAttenuation - source.minAttenuation;\n\t\t\t\t\tfloat t = (distance - source.minAttenuation) / range;\n\n\t\t\t\t\tfloat attenuation = 1.0f - t;\n\t\t\t\t\tfor (int i = 0; i < SIMPLE_SOUND_MAX_CHANNELS; gain[i++] *= attenuation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tunsigned int sourceOffsetInSamples = looping? source.cursor % pcmNumSamples : uiMin(source.cursor, pcmNumSamples);\n\t\tdestOffsetInSamples = uiMin(destOffsetInSamples, destination.owner->numSamples);\n\t\tunsigned int numSamplesToCopy = destination.owner->numSamples - destOffsetInSamples;\n\t\t\n\t\tfor (unsigned int sample = destOffsetInSamples; sample < numSamplesToCopy; ++sample) {\n\t\t\tunsigned int busIndex = (sample * numChannels);\n\t\t\tunsigned int soundIndex = source.cursor * numChannels;\n\n\t\t\tif (numChannels >= 1) {\n\t\t\t\tdestination.mix[busIndex + 0] += float(samples[soundIndex + 0]) * volume * gain[0] - (clear ? destination.mix[busIndex + 0] : 0.0f);\n\t\t\t}\n\t\t\tif (numChannels >= 2) {\n\t\t\t\tdestination.mix[busIndex + 1] += float(samples[soundIndex + 1]) * volume * gain[1] - (clear ? destination.mix[busIndex + 1] : 0.0f);\n\t\t\t}\n\t\t\tif (numChannels >= 4) {\n\t\t\t\tdestination.mix[busIndex + 2] += float(samples[soundIndex + 2]) * volume * gain[2] - (clear ? destination.mix[busIndex + 2] : 0.0f);\n\t\t\t\tdestination.mix[busIndex + 3] += float(samples[soundIndex + 3]) * volume * gain[3] - (clear ? destination.mix[busIndex + 3] : 0.0f);\n\t\t\t}\n\t\t\tif (numChannels >= 6) {\n\t\t\t\tdestination.mix[busIndex + 4] += float(samples[soundIndex + 4]) * volume * gain[4] - (clear ? destination.mix[busIndex + 4] : 0.0f);\n\t\t\t\tdestination.mix[busIndex + 5] += float(samples[soundIndex + 5]) * volume * gain[5] - (clear ? destination.mix[busIndex + 5] : 0.0f);\n\t\t\t}\n\n\t\t\tif (looping) {\n\t\t\t\tsource.cursor = (source.cursor + 1) % pcmNumSamples;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.cursor += 1;\n\t\t\t\tif (source.cursor >= pcmNumSamples) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdestination.clear = false;\n\t\t\t\n\t\tif (looping) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn source.cursor >= pcmNumSamples; // Sound can keep playing!\n\t}\n\n\tvoid Mix(Device& device, Bus& bus, bool clear) {\n\t\tunsigned int numChannels = device.numChannels;\n\t\tunsigned int numSamples = device.numSamples;\n\n\t\tfloat* dest = device.mixer;\n\t\tfloat* source = bus.mix;\n\t\t\n\t\tfloat volume = bus.volume;\n\t\tLeftRightGain pan = LeftAndRightGainFromPan(device, bus.pan);\n\n\t\tfloat gain[SIMPLE_SOUND_MAX_CHANNELS];\n\t\tfor (int i = 0; i < SIMPLE_SOUND_MAX_CHANNELS; gain[i++] = 1.0f);\n\t\tif (numChannels == 2) {\n\t\t\tgain[0] = pan.leftGain;\n\t\t\tgain[1] = pan.rightGain;\n\t\t}\n\t\t\n\t\tfor (unsigned int i = 0; i < numSamples * numChannels; ++i) {\n\t\t\tdest[i] += source[i] * volume * gain[i % numChannels] -(clear ? dest[i] : 0);\n\t\t}\n\t}\n\n\tvoid Blit(Device& device, unsigned int targetChunk) {\n\t\tunsigned int numChunks = 2; // 2 chunks since it's double buffered\n\t\tunsigned int numChannels = device.numChannels;\n\t\tunsigned int samplesize = sizeof(short) * numChannels;\n\t\tunsigned int numSamplesInBuffer = device.bufferSize / samplesize;\n\t\tunsigned int numSamplesInChunk = numSamplesInBuffer / numChunks;\n\n\t\tfloat* input = device.mixer;\n\t\tshort* output = &device.buffer[targetChunk * numSamplesInChunk * numChannels];\n\t\t\n\t\tfloat volume = device.volume;\n\t\tLeftRightGain gain = LeftAndRightGainFromPan(device, device.pan);\n\t\t\n\t\tif (numChannels == 2) { // Pan is only applied if there are two speakers\n\t\t\tfor (unsigned int i = 0; i < numSamplesInChunk * numChannels; i += 2) { // Could multiply this by numChannels to avoid the manual if statements below\n\t\t\t\t// Clip sound if it's out of range\n\t\t\t\tfloat value = input[i + 0] * volume * gain.leftGain;\n\t\t\t\tif (value < -32768.0f) {\n\t\t\t\t\toutput[i + 0] = -32768;\n\t\t\t\t}\n\t\t\t\telse if (value > 32767.0f) {\n\t\t\t\t\toutput[i + 0] = 32767;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[i + 0] = value;\n\t\t\t\t}\n\n\t\t\t\tvalue = input[i + 1] * volume * gain.rightGain;\n\t\t\t\tif (value < -32768.0f) {\n\t\t\t\t\toutput[i + 1] = -32768;\n\t\t\t\t}\n\t\t\t\telse if (value > 32767.0f) {\n\t\t\t\t\toutput[i + 1] = 32767;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[i + 1] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (unsigned int i = 0; i < numSamplesInChunk * numChannels; ++i) { // Could multiply this by numChannels to avoid the manual if statements below\n\t\t\t\t// Clip sound if it's out of range\n\t\t\t\tfloat value = input[i] * volume;\n\t\t\t\tif (value < -32768.0f) {\n\t\t\t\t\toutput[i] = -32768;\n\t\t\t\t}\n\t\t\t\telse if (value > 32767.0f) {\n\t\t\t\t\toutput[i] = 32767;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Submit PCM data to sound card\n\t\tunsigned int chunkSizeInBytes = numSamplesInChunk * samplesize;\n\t\tWasmSubmitPcmBytes(&device, targetChunk * chunkSizeInBytes, output, chunkSizeInBytes);\n\t}\n\n\tDevice* InitWithTime(Platform& platform, unsigned int bufferLengthMs, unsigned int numChannels, void* hwndPtr) {\n\t\tunsigned int sampleSize = sizeof(short) * numChannels;\n\t\tunsigned int samplesPerSecond = 48000;\n\t\tunsigned int samplesPerMillisecond = samplesPerSecond / 1000; // 48\n\n\t\tunsigned int numSamplesInChunk = bufferLengthMs * samplesPerMillisecond; // At 16ms (60 fps), this should be 768 samples per frame\n\t\t\n\t\treturn InitWithSamples(platform, numSamplesInChunk, numChannels, hwndPtr);\n\t}\n\n\tvoid MakeLeftHanded(Device& device) {\n\t\tdevice.mRightHanded = true;\n\t}\n\n\tvoid MakeRightHanded(Device& device) {\n\t\tdevice.mRightHanded = false;\n\t}\n\n\tDevice* InitWithSamples(Platform& platform, unsigned int sampleCount, unsigned int numChannels, void* hwndPtr) {\n\t\tif (numChannels > SIMPLE_SOUND_MAX_CHANNELS) {\n\t\t\tnumChannels = SIMPLE_SOUND_MAX_CHANNELS;\n\t\t}\n\n\t\tDevice* result = (Device*)platform.allocate(sizeof(Device));\n\n\t\tresult->platform = platform;\n\t\tresult->numChannels = numChannels;\n\t\tresult->isValid = true;\n\t\tresult->buses = 0;\n\t\tresult->volume = 1.0f;\n\t\tresult->pan = 0.0f;\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(*result, result->pan);\n\t\tresult->gainLeft = leftRightGain.leftGain;\n\t\tresult->gainRight = leftRightGain.rightGain;\n\t\tresult->mixer = 0;\n\t\tresult->buffer = 0;\n\t\tresult->buffer_unaligned = 0;\n\t\tresult->bufferSize = 0;\n\t\tresult->mRightHanded = true;\n\t\tresult->activeChunkIndex = 0;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tresult->getResult[i] = 0.0f;\n\t\t\tresult->listenerPosition[i] = 0.0f;\n\t\t\tresult->listenerForward[i] = 0.0f;\n\t\t\tresult->listenerUp[i] = 0.0f;\n\t\t}\n\t\tresult->getResult[3] = 0.0f;\n\t\tfor (int i = 0; i < 9; result->listenerMat[i++] = 0.0f);\n\t\tresult->listenerMat[0] = result->listenerMat[4] = result->listenerMat[8] = 1.0f;\n\n\t\tresult->errorMsg = (char*)platform.allocate(sizeof(char) * SIMPLE_SOUND_ERROR_MSG_LEN);\n\t\t\n\t\tunsigned int size = sizeof(char) * SIMPLE_SOUND_ERROR_MSG_LEN;\n\t\tfor (unsigned int i = 0; i < size; ++i) {\n\t\t\tresult->errorMsg[i] = 0.0f;\n\t\t}\n\n\t\t// These are constant\n\t\tunsigned int sampleSize = sizeof(short) * numChannels;\n\t\tunsigned int samplesPerSecond = 48000;\n\n\t\tunsigned int numSamplesInChunk = sampleCount;\n\t\tunsigned int chunkSizeInBytes = numSamplesInChunk * sampleSize;\n\t\tresult->numSamples = numSamplesInChunk;\n\n\t\t// The audio works with a double buffer scheme. Allocate enough for both.\n\t\tunsigned int bufferSize = chunkSizeInBytes * 2;\n\n\t\tresult->isValid = true;\n\t\tresult->mixer = (float*)platform.allocate(sizeof(float) * numSamplesInChunk * numChannels);\n\t\tresult->buffer = (short*)platform.allocate(bufferSize + 4); // Already in bytes. +4 is so we can align (it only needs to be +2 tough)\n\t\tresult->buffer_unaligned = result->buffer;\n\t\tif ((unsigned long)result->buffer % 2 != 0) {\n\t\t\tresult->buffer = result->buffer + 1;\n\t\t}\n\t\tresult->bufferSize = bufferSize;\n\t\tSetListener(*result, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f);\n\n\t\tfor (unsigned int i = 0; i < result->numChannels * result->numSamples; result->mixer[i++] = 0.0f);\n\t\tfor (unsigned int i = 0; i < result->bufferSize / sizeof(short); result->buffer[i++] = 0);\n\t\tWasmSubmitPcmBytes(result, 0, result->buffer, result->bufferSize);\n\t\t\n\t\tWasmRegisterAudioDevice(result);\n\t\treturn result;\n\t}\n\n\tvoid Shutdown(Device* device) {\n\t\tWasmRemoveAudioDevice(device);\n\n\t\tfor (Bus* bus = device->buses; bus != 0;) {\n\t\t\tBus* process = bus;\n\t\t\tbus = bus->next;\n\t\t\tDestroy(process);\n\t\t}\n\t\t\n\t\tif (device->errorMsg != 0) {\n\t\t\tdevice->platform.release(device->errorMsg);\n\t\t}\n\t\tif (device->buffer != 0) {\n\t\t\tdevice->platform.release(device->buffer_unaligned);\n\t\t}\n\t\tif (device->mixer != 0) {\n\t\t\tdevice->platform.release(device->mixer);\n\t\t}\n\n\t\tdevice->platform.release(device);\n\t}\n\n\tbool IsValid(Device& device) {\n\t\treturn device.isValid;\n\t}\n\n\tconst char* GetLastError(Device& device) {\n\t\tif (device.isValid) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Make sure it's null terminated\n\t\tdevice.errorMsg[SIMPLE_SOUND_ERROR_MSG_LEN - 1] = '\\0';\n\t\treturn device.errorMsg;\n\t}\n\n\tunsigned int GetNumChannels(Device& device) {\n\t\treturn device.numChannels;\n\t}\n\n\tBus* CreateBus(Device& device) {\n\t\t// Step 1, make bus\n\t\tBus* result = (Bus*)device.platform.allocate(sizeof(Bus));\n\t\tresult->owner = &device;\n\t\tresult->sounds = 0;\n\t\tresult->prev = 0;\n\t\tresult->next = 0;\n\t\tresult->volume = 1.0f;\n\t\tresult->pan = 0.0f;\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(device, result->pan);\n\t\tresult->gainLeft = leftRightGain.leftGain;\n\t\tresult->gainRight = leftRightGain.rightGain;\n\t\tresult->mix = (float*) device.platform.allocate(sizeof(float) * device.numChannels * device.numSamples);\n\t\tresult->clear = false;\n\n\t\t// Step 2, Hook up to track\n\t\tif (device.buses != 0) {\n\t\t\tdevice.buses->prev = result;\n\t\t}\n\t\tresult->next = device.buses;\n\t\tdevice.buses = result;\n\n\t\t// Step 3, Clear\n\t\tresult->clear = true; // No sounds yet, clear bus on init\n\t\tfor (unsigned int i = 0; i < device.numChannels * device.numSamples; result->mix[i++] = 0.0f);\n\n\t\treturn result;\n\t}\n\n\tSound* Play(Bus& bus, PCMData& pcm, bool looping) {\n\t\tSound* result = (Sound*)bus.owner->platform.allocate(sizeof(Sound));\n\t\tresult->source = &pcm;\n\t\tresult->owner = &bus;\n\t\tresult->prev = 0;\n\t\tresult->next = 0;\n\t\tresult->volume = 1.0f;\n\t\tresult->pan = 0.0f;\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(*bus.owner, result->pan);\n\t\tresult->gainLeft = leftRightGain.leftGain;\n\t\tresult->gainRight = leftRightGain.rightGain;\n\t\tresult->looping = looping;\n\t\tresult->cursor = 0;\n\t\tresult->paused = false;\n\n\t\tresult->isSpatialized = false;\n\t\tresult->position[0] = 0.0f;\n\t\tresult->position[1] = 0.0f;\n\t\tresult->position[2] = 0.0f;\n\t\tresult->minAttenuation = 0.0f;\n\t\tresult->maxAttenuation = 0.0f;\n\n\t\tif (bus.sounds != 0) {\n\t\t\tbus.sounds->prev = result;\n\t\t}\n\t\tresult->next = bus.sounds;\n\t\tbus.sounds = result;\n\n\t\tif (Mix(bus, *result, 0, false)) {\n\t\t\tStop(result);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tSound* Play(Bus& bus, PCMData& pcm, float x, float y, float z, bool looping, float minAttenuation, float maxAttenuation) {\n\t\tSound* result = (Sound*)bus.owner->platform.allocate(sizeof(Sound));\n\t\tresult->source = &pcm;\n\t\tresult->owner = &bus;\n\t\tresult->prev = 0;\n\t\tresult->next = 0;\n\t\tresult->volume = 1.0f;\n\t\tresult->pan = 0.0f;\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(*bus.owner, result->pan);\n\t\tresult->gainLeft = leftRightGain.leftGain;\n\t\tresult->gainRight = leftRightGain.rightGain;\n\t\tresult->looping = looping;\n\t\tresult->cursor = 0;\n\t\tresult->paused = false;\n\n\t\tif (bus.sounds != 0) {\n\t\t\tbus.sounds->prev = result;\n\t\t}\n\t\tresult->next = bus.sounds;\n\t\tbus.sounds = result;\n\n\t\tif (Mix(bus, *result, 0, false)) {\n\t\t\tStop(result);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn result;\n\n\t\tresult->isSpatialized = true;\n\t\tresult->position[0] = x;\n\t\tresult->position[1] = y;\n\t\tresult->position[2] = z;\n\t\tresult->minAttenuation = minAttenuation;\n\t\tresult->maxAttenuation = maxAttenuation;\n\n\t\treturn result;\n\t}\n\n\tvoid Stop(Sound* sound) {\n\t\t// Unlink\n\t\tBus* bus = sound->owner;\n\t\tif (sound->next != 0) {\n\t\t\tsound->next->prev = sound->prev;\n\t\t}\n\t\tif (sound->prev != 0) {\n\t\t\tsound->prev->next = sound->next;\n\t\t}\n\t\tif (bus->sounds == sound) {\n\t\t\tbus->sounds = sound->next;\n\t\t}\n\n\t\t// Delete\n\t\tDevice* device = bus->owner;\n\t\tdevice->platform.release(sound);\n\t}\n\n\tvoid Destroy(Bus* bus) {\n\t\tfor (Sound* sound = bus->sounds; sound != 0;) {\n\t\t\tSound* process = sound;\n\t\t\tsound = sound->next;\n\t\t\tStop(process);\n\t\t}\n\n\t\t// Release mixer\n\t\tif (bus->mix != 0) {\n\t\t\tbus->owner->platform.release(bus->mix);\n\t\t}\n\n\t\t// Unhook from tracked busses\n\t\tif (bus->next != 0) {\n\t\t\tbus->next->prev = bus->prev;\n\t\t}\n\t\tif (bus->prev != 0) {\n\t\t\tbus->prev->next = bus->next;\n\t\t}\n\t\tif (bus == bus->owner->buses) {\n\t\t\tbus->owner->buses = bus->next;\n\t\t}\n\n\t\t// Release bus\n\t\tbus->owner->platform.release(bus);\n\t}\n\n\tunsigned int GetNumChannels(Bus& bus) {\n\t\treturn bus.owner->numChannels;\n\t}\n\n\tvoid SetVolume(Device& device, float volume) {\n\t\tif (volume < 0.0f) {\n\t\t\tvolume = 0.0f;\n\t\t}\n\t\tif (volume > 1.0f) {\n\t\t\tvolume = 1.0f;\n\t\t}\n\t\tdevice.volume = volume;\n\t}\n\n\tvoid SetVolume(Bus& bus, float volume) {\n\t\tif (volume < 0.0f) {\n\t\t\tvolume = 0.0f;\n\t\t}\n\t\tif (volume > 1.0f) {\n\t\t\tvolume = 1.0f;\n\t\t}\n\t\tbus.volume = volume;\n\t}\n\n\tfloat GetVolume(Device& device) {\n\t\treturn device.volume;\n\t}\n\n\tfloat GetVolume(Bus& bus) {\n\t\treturn bus.volume;\n\t}\n\n\tfloat GetPan(Device& device) {\n\t\treturn device.pan;\n\t}\n\n\tfloat GetPan(Bus& bus) {\n\t\treturn bus.pan;\n\t}\n\n\tvoid SetPan(Device& device, float pan) {\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(device, pan);\n\t\tdevice.gainLeft = leftRightGain.leftGain;\n\t\tdevice.gainRight = leftRightGain.rightGain;\n\t\tdevice.pan = pan;\n\t}\n\n\tvoid SetPan(Bus& bus, float pan) {\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(*bus.owner, pan);\n\t\tbus.gainLeft = leftRightGain.leftGain;\n\t\tbus.gainRight = leftRightGain.rightGain;\n\t\tbus.pan = pan;\n\t}\n\n\tunsigned int GetNumChannels(PCMData& pcm) {\n\t\treturn pcm.numChannels;\n\t}\n\n\tshort* GetOut(Device& device) {\n\t\treturn device.buffer;\n\t}\n\n\tfloat* GetMixer(Device& device) {\n\t\treturn device.mixer;\n\t}\n\n\tfloat* GetMixer(Bus& bus) {\n\t\treturn bus.mix;\n\t}\n\n\tunsigned int GetNumChannels(Sound& sound) {\n\t\treturn sound.owner->owner->numChannels;\n\t}\n\n\tvoid SetPan(Sound& sound, float pan) {\n\t\tLeftRightGain leftRightGain = LeftAndRightGainFromPan(*sound.owner->owner, pan);\n\t\tsound.gainLeft = leftRightGain.leftGain;\n\t\tsound.gainRight = leftRightGain.rightGain;\n\t\tsound.pan = pan;\n\t}\n\n\tfloat GetPan(Sound& sound) {\n\t\treturn sound.pan;\n\t}\n\n\tvoid SetVolume(Sound& sound, float volume) {\n\t\tif (volume < 0.0f) {\n\t\t\tvolume = 0.0f;\n\t\t}\n\t\tif (volume > 1.0f) {\n\t\t\tvolume = 1.0f;\n\t\t}\n\t\tsound.volume = volume;\n\t}\n\n\tfloat GetVolume(Sound& sound) {\n\t\treturn sound.volume;\n\t}\n\n\tbool IsValid(Sound& sound) {\n\t\tif (sound.looping) {\n\t\t\treturn true;\n\t\t}\n\n\t\tshort cursor = (short)sound.cursor;\n\t\tif (cursor >= sound.source->numSamples) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvoid Pause(Sound* sound) {\n\t\tsound->paused = true;\n\t}\n\n\tvoid Resume(Sound* sound) {\n\t\tsound->paused = false;\n\t}\n\n\tvoid SetAttenuation(Sound* sound, float aMin, float aMax) {\n\t\tsound->minAttenuation = aMin;\n\t\tsound->maxAttenuation = aMax;\n\t}\n\n\tfloat GetMinAttenuation(Sound* sound) {\n\t\treturn sound->minAttenuation;\n\t}\n\n\tfloat GetMaxAttenuation(Sound* sound) {\n\t\treturn sound->maxAttenuation;\n\t}\n\n\tvoid SetPosition(Sound* sound, float x, float y, float z) {\n\t\tsound->position[0] = x;\n\t\tsound->position[1] = y;\n\t\tsound->position[2] = z;\n\t}\n\n\tfloat* GetPosition(Sound* sound) {\n\t\tfloat* result = sound->owner->owner->getResult;\n\t\tresult[0] = sound->position[0];\n\t\tresult[1] = sound->position[1];\n\t\tresult[2] = sound->position[2];\n\t\tresult[3] = 0.0f;\n\t\treturn result;\n\t}\n\n\tfloat* GetListenerPosition(Device& device) {\n\t\tfloat* result = device.getResult;\n\t\tresult[0] = device.listenerPosition[0];\n\t\tresult[1] = device.listenerPosition[1];\n\t\tresult[2] = device.listenerPosition[2];\n\t\tresult[3] = 0.0f;\n\t\treturn result;\n\t}\n\n\tfloat* GetListenerForward(Device& device) {\n\t\tfloat* result = device.getResult;\n\t\tresult[0] = device.listenerForward[0];\n\t\tresult[1] = device.listenerForward[1];\n\t\tresult[2] = device.listenerForward[2];\n\t\tresult[3] = 0.0f;\n\t\treturn result;\n\t}\n\n\tfloat* GetListenerUp(Device& device) {\n\t\tfloat* result = device.getResult;\n\t\tresult[0] = device.listenerUp[0];\n\t\tresult[1] = device.listenerUp[1];\n\t\tresult[2] = device.listenerUp[2];\n\t\tresult[3] = 0.0f;\n\t\treturn result;\n\t}\n\n\tvoid SetListener(Device& device, float posX, float posY, float posZ, float fwdX, float fwdY, float fwdZ, float upX, float upY, float upZ) {\n\t\tfloat forward[3] = { fwdX, fwdY, fwdZ };\n\t\tNormalize(device.platform, forward);\n\n\t\tfloat up[3] = { upX, upY, upZ };\n\t\tNormalize(device.platform, up);\n\n\t\tfloat right[3] = { 0.0f, 0.0f, 0.0f };\n\t\tif (device.mRightHanded) {\n\t\t\tCross(right, forward, up);\n\t\t}\n\t\telse {\n\t\t\tCross(right, up, forward);\n\t\t}\n\n\t\tdevice.listenerForward[0] = forward[0];\n\t\tdevice.listenerForward[1] = forward[1];\n\t\tdevice.listenerForward[2] = forward[2];\n\n\t\tdevice.listenerUp[0] = up[0];\n\t\tdevice.listenerUp[1] = up[1];\n\t\tdevice.listenerUp[2] = up[2];\n\n\t\tdevice.listenerPosition[0] = posX;\n\t\tdevice.listenerPosition[1] = posY;\n\t\tdevice.listenerPosition[2] = posZ;\n\n\t\tdevice.listenerMat[0] = right[0];\n\t\tdevice.listenerMat[1] = right[1];\n\t\tdevice.listenerMat[2] = right[2];\n\n\t\tdevice.listenerMat[3] = up[0];\n\t\tdevice.listenerMat[4] = up[1];\n\t\tdevice.listenerMat[5] = up[2];\n\n\t\tdevice.listenerMat[6] = forward[0];\n\t\tdevice.listenerMat[7] = forward[1];\n\t\tdevice.listenerMat[8] = forward[2];\n\t}\n};\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void FillWithDebugSound(SimpleSound::Device* device) {\n\tint hertz = 261;\n\n\tunsigned int numSamples = device->numSamples;\n\tunsigned int numChannels = device->numChannels;\n\n\tint squareWavePeriod = 48000 / hertz;\n\tshort tone = 1200;\n\tfor (unsigned int i = 0; i < numSamples; ++i) {\n\t\tif (squareWavePeriod-- == 0) {\n\t\t\ttone = tone * -1;\n\t\t\tsquareWavePeriod = 48000 / hertz;\n\t\t}\n\n\t\tif (numChannels >= 1) {\n\t\t\tdevice->buffer[i * numChannels + 0] = tone;\n\t\t}\n\t\tif (numChannels >= 2) {\n\t\t\tdevice->buffer[i * numChannels + 1] = tone;\n\t\t}\n\t\tif (numChannels >= 4) {\n\t\t\tdevice->buffer[i * numChannels + 2] = tone;\n\t\t\tdevice->buffer[i * numChannels + 3] = tone;\n\t\t}\n\t\tif (numChannels >= 6) {\n\t\t\tdevice->buffer[i * numChannels + 4] = tone;\n\t\t\tdevice->buffer[i * numChannels + 5] = tone;\n\t\t}\n\t}\n\n\tsquareWavePeriod = 48000 / hertz;\n\ttone = 1200;\n\tfor (unsigned int i = 0; i < numSamples; ++i) {\n\t\tif (squareWavePeriod-- == 0) {\n\t\t\ttone = tone * -1;\n\t\t\tsquareWavePeriod = 48000 / hertz;\n\t\t}\n\n\t\tif (numChannels >= 1) {\n\t\t\tdevice->mixer[i * numChannels + 0] = tone;\n\t\t}\n\t\tif (numChannels >= 2) {\n\t\t\tdevice->mixer[i * numChannels + 1] = tone;\n\t\t}\n\t\tif (numChannels >= 4) {\n\t\t\tdevice->mixer[i * numChannels + 2] = tone;\n\t\t\tdevice->mixer[i * numChannels + 3] = tone;\n\t\t}\n\t\tif (numChannels >= 6) {\n\t\t\tdevice->mixer[i * numChannels + 4] = tone;\n\t\t\tdevice->mixer[i * numChannels + 5] = tone;\n\t\t}\n\t}\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void AudioTick(SimpleSound::Device* device) {\n\t\tif (device == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tunsigned int numChannels = device->numChannels;\n\n\t\tunsigned int numChunks = 2; // 2 chunks since it's double buffered\n\t\tunsigned int samplesize = sizeof(short) * device->numChannels;\n\n\t\tunsigned int numSamplesInBuffer = device->bufferSize / samplesize;\n\t\tunsigned int numSamplesInChunk = numSamplesInBuffer / numChunks;\n\n\t\t{\n\t\t\t// Synch audio based on how far the main buffer has played\n\t\t\tunsigned int playCursorInBytes = WasmGetCurrentPosition();\n\t\t\tunsigned int playCursorInSamples = playCursorInBytes / samplesize;\n\t\t\t\n\t\t\tunsigned int chunkIndex = playCursorInSamples / numSamplesInChunk;\n\t\t\tunsigned int nextChunk = (chunkIndex + 1) % numChunks;\n\n\t\t\t// Entering next chunk, dump all data, and mix into the one we just left\n\t\t\tif (device->activeChunkIndex != chunkIndex) {\n\t\t\t\t// All sounds have already been mixed into the mix of each bus\n\t\t\t\t// Clear the device mixer and Blast all buses into the device mixer\n\t\t\t\tSimpleSound::Bus* bus = device->buses;\n\t\t\t\tif (bus != 0) { // First bus being mixed into the device should clear the device\n\t\t\t\t\t// Doing this saves us a memset, since the mix function happens regardless.\n\t\t\t\t\tSimpleSound::Mix(*device, *bus, true);\n\t\t\t\t\tbus = bus->next;\n\t\t\t\t}\n\t\t\t\tfor (; bus != 0; bus = bus->next) {\n\t\t\t\t\tSimpleSound::Mix(*device, *bus, false);\n\t\t\t\t}\n\n\t\t\t\t// Now that everything is mixed, convert float buffer to short buffer\n\t\t\t\tSimpleSound::Blit(*device, nextChunk); \n\t\t\t\t// If there are any sounds left over, or looping, mix overflow for next frame\n\t\t\t\tfor (SimpleSound::Bus* bus = device->buses; bus != 0; bus = bus->next) {\n\t\t\t\t\tSimpleSound::Sound* sound = bus->sounds;\n\t\t\t\t\tif (sound != 0) { // Clear bus mixer for first sound, avoiding a memset\n\t\t\t\t\t\tSimpleSound::Sound* process = sound;\n\t\t\t\t\t\tsound = sound->next;\n\t\t\t\t\t\tif (SimpleSound::Mix(*bus, *process, 0, true)) {\n\t\t\t\t\t\t\tSimpleSound::Stop(process);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!bus->clear) { // No sounds, clear bus\n\t\t\t\t\t\tbus->clear = true; \n\t\t\t\t\t\tfor (unsigned int i = 0; i < device->numChannels * device->numSamples; bus->mix[i++] = 0.0f);\n\t\t\t\t\t}\n\t\t\t\t\tfor (; sound != 0; ) {\n\t\t\t\t\t\tSimpleSound::Sound* process = sound;\n\t\t\t\t\t\tsound = sound->next;\n\t\t\t\t\t\tif (SimpleSound::Mix(*bus, *process, 0, false)) {\n\t\t\t\t\t\t\tSimpleSound::Stop(process);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// SwapBuffers\n\t\t\t\tdevice->activeChunkIndex = chunkIndex;\n\t\t\t}\n\t\t}\n\t}"],"mappings":"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"}